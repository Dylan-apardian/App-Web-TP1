/*!
 * Module dependencies.
 */

<<<<<<< HEAD
'use strict';

const MongooseError = require('./');


class ValidatorError extends MongooseError {
  /**
   * Schema validator error
   *
   * @param {Object} properties
   * @api private
   */
  constructor(properties) {
    let msg = properties.message;
    if (!msg) {
      msg = MongooseError.messages.general.default;
    }

    const message = formatMessage(msg, properties);
    super(message);

    properties = Object.assign({}, properties, { message: message });
    this.properties = properties;
    this.kind = properties.type;
    this.path = properties.path;
    this.value = properties.value;
    this.reason = properties.reason;
  }

  /*!
   * toString helper
   * TODO remove? This defaults to `${this.name}: ${this.message}`
   */
  toString() {
    return this.message;
  }

  /*!
   * Ensure `name` and `message` show up in toJSON output re: gh-9296
   */

  toJSON() {
    return Object.assign({ name: this.name, message: this.message }, this);
  }
}


Object.defineProperty(ValidatorError.prototype, 'name', {
  value: 'ValidatorError'
});
=======
var MongooseError = require('./');

/**
 * Schema validator error
 *
 * @param {Object} properties
 * @inherits MongooseError
 * @api private
 */

function ValidatorError(properties) {
  var msg = properties.message;
  if (!msg) {
    msg = MongooseError.messages.general.default;
  }

  var message = this.formatMessage(msg, properties);
  MongooseError.call(this, message);
  this.name = 'ValidatorError';
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this);
  } else {
    this.stack = new Error().stack;
  }
  this.properties = properties;
  this.kind = properties.type;
  this.path = properties.path;
  this.value = properties.value;
  this.reason = properties.reason;
}

/*!
 * Inherits from MongooseError
 */

ValidatorError.prototype = Object.create(MongooseError.prototype);
ValidatorError.prototype.constructor = MongooseError;
>>>>>>> 67dff727551b6248efacc127c2432d1747d92b89

/*!
 * The object used to define this validator. Not enumerable to hide
 * it from `require('util').inspect()` output re: gh-3925
 */

Object.defineProperty(ValidatorError.prototype, 'properties', {
  enumerable: false,
  writable: true,
  value: null
});

<<<<<<< HEAD
// Exposed for testing
ValidatorError.prototype.formatMessage = formatMessage;

=======
>>>>>>> 67dff727551b6248efacc127c2432d1747d92b89
/*!
 * Formats error messages
 */

<<<<<<< HEAD
function formatMessage(msg, properties) {
  if (typeof msg === 'function') {
    return msg(properties);
  }

  const propertyNames = Object.keys(properties);
  for (const propertyName of propertyNames) {
=======
ValidatorError.prototype.formatMessage = function(msg, properties) {
  var propertyNames = Object.keys(properties);
  for (var i = 0; i < propertyNames.length; ++i) {
    var propertyName = propertyNames[i];
>>>>>>> 67dff727551b6248efacc127c2432d1747d92b89
    if (propertyName === 'message') {
      continue;
    }
    msg = msg.replace('{' + propertyName.toUpperCase() + '}', properties[propertyName]);
  }
<<<<<<< HEAD

  return msg;
}
=======
  return msg;
};

/*!
 * toString helper
 */

ValidatorError.prototype.toString = function() {
  return this.message;
};
>>>>>>> 67dff727551b6248efacc127c2432d1747d92b89

/*!
 * exports
 */

module.exports = ValidatorError;
